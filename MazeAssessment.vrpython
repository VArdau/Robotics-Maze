{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n\nimport math\nfrom vexcode_vr import *\n\ndef main():\n    # To make it go faster\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    visited = set()  # Track visited positions to avoid loops\n    path = []  # Stack to store the necessary path\n    movement_step = 250  # Distance per movement\n    start_position = None\n    end_position = None\n\n    # Move towards the red tile using right-wall following\n    while True:\n        # Get current position\n        x = round(location.position(X, MM))\n        y = round(location.position(Y, MM))\n        current_position = (x, y)\n\n        pen.set_pen_color(BLUE)\n        pen.move(DOWN)\n\n        if start_position is None:\n            start_position = current_position  # Set the start position\n\n        # If the robot detects the red tile, stop and mark the end\n        if down_eye.detect(RED):\n            end_position = current_position\n            drivetrain.stop()\n            break  \n\n        # Avoid looping by checking if the position is already visited\n        if current_position in visited:\n            while path and path[-1] != current_position:\n                path.pop()  # Remove unnecessary steps\n        else:\n            visited.add(current_position)  # Mark position as visited\n\n        path.append(current_position)  # Store necessary steps\n\n        # Right Wall Follow logic\n        if front_eye.detect(RED):  # If wall in front, turn left\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        else:\n            drivetrain.drive_for(FORWARD, movement_step, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)  # Turn right to follow the wall\n\n        wait(2, MSEC)\n\n    # Ensure the red position is included in the path (before it would count it as a step)\n    if path[-1] != end_position:\n        path.append(end_position)  \n\n    # Retrace the shortest path back to the start (Green tile)\n    pen.set_pen_color(RED)\n    for position in reversed(path):  \n        x, y = position\n        go_to(x, y)\n\n    # Shows its shortest route no matter from where you entered\n    for position in path: \n        x, y = position\n        go_to(x, y)\n\n    # Get more of the map covered \n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n    pen.set_pen_color(BLUE)\n    while True:\n        if front_eye.detect(RED):  \n            drivetrain.turn_for(LEFT, 90, DEGREES)  \n        else:\n            drivetrain.drive_for(FORWARD, movement_step, MM)\n            drivetrain.turn_for(RIGHT, 90, DEGREES)  \n\n        # Check if robot is close enough to the green tile\n        final_x = round(location.position(X, MM))\n        final_y = round(location.position(Y, MM))\n        tolerance = 100  # Tolerance for proximity to the green tile (had issues with it not wanting to stop)\n\n        distance_to_start = math.sqrt((final_x - start_position[0])**2 + (final_y - start_position[1])**2)\n\n        if distance_to_start < tolerance:  \n            drivetrain.stop()  # Stop at the green tile\n            break  # Exit loop\n\n        wait(2, MSEC)\n\n    pen.move(UP)\n    stop_project()\n\n# Function to move the robot to a specific coordinate\ndef go_to(x_loc, y_loc):\n    # Calculate movement vector\n    a = x_loc - location.position(X, MM)\n    b = y_loc - location.position(Y, MM)\n\n    if a == 0 and b == 0:\n        return  # Already at the position\n\n    # Calculate distance to target\n    c = math.sqrt(a**2 + b**2)\n\n    # Calculate the angle needed to turn\n    angle = math.degrees(math.asin(a / c))\n\n    if b < 0:\n        angle = 180 - angle  # Adjust the angle for backward movement\n\n    # Turn towards target position\n    drivetrain.turn_to_heading(angle, DEGREES)\n\n    # Gradual deceleration as the robot gets closer (would crash at the red tile)\n    if c < 100:  # Slow down if close\n        drivetrain.set_drive_velocity(50, PERCENT)\n\n    drivetrain.drive_for(FORWARD, c, MM)\n\n    # Reset to full speed after moving\n    drivetrain.set_drive_velocity(100, PERCENT)\n\n\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}